"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
/**
 * Build a RegExp matching the values of secure environment variables.
 *
 * @param secureEnv A list of environment variable names to redact
 * @param env Where to read the values from (defaults to process.env)
 */
exports.build = (secureEnv, env = process.env) => {
    const unified = Object.keys(env)
        .filter(env => secureEnv.includes(env))
        .map(envName => {
        const value = env[envName];
        // Ignore JSON values that are too generic (might erase other fields)
        if (!value || ['true', 'false', 'null'].includes(value)) {
            return null;
        }
        const escapedValue = escape_string_regexp_1.default(value);
        return `(${escapedValue})`;
    })
        .filter(x => !!x)
        .join('|');
    if (unified === '') {
        // Use negated negative lookahead to never match anything
        // https://stackoverflow.com/questions/1723182/a-regex-that-will-never-be-matched-by-anything
        return new RegExp(/(?!)/, 'g');
    }
    return new RegExp(unified, 'g');
};
// --
/**
 * Redact a string based on a built RegExp (from redactEnv.build).
 *
 * @param input The input string to redact
 * @param regexp A RegExp built by redactEnv.build
 * @param replace What to replace redacted text with (defaults to '\[secure\]')
 */
exports.redact = (input, regexp, replace = '[secure]') => {
    return input.replace(regexp, replace);
};
// --
exports.default = {
    build: exports.build,
    redact: exports.redact
};
